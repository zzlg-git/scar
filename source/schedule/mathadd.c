/***********************************************************************
**  Copyright (c)  Smartcar Lab of USTB
***********************************************************************/

/*--------------- I N C L U D E S ------------------------------------*/
#include "common.h"
#include "mathadd.h"
/*--------------- M A C R O S ----------------------------------------*/

/*******************************************************
NAME     : Integer_Sqrt
FUNCTION : 整数开平方
INPUT    : INT32S Input  x^2
OUTPUT   : INT32S Result x
NOTES    : SQRT_PRECISION 计算精度
               SQRT_ITERATION 最大迭代次数
*******************************************************/
int int_sqrt(INT32U x2)
{
    INT32U S_0     = 0;
    INT32U S_down  = 0;
    INT32U S_mid   = 0;
    INT32U S_up    = 0;
    INT32U S_temp  = 0;
    INT8U  S_count = 0;

    static const INT32S PRECISION = 1;
    static const INT8U ITERATION = 20;

    S_0   = x2;
    S_down = 0;
    S_up  = x2;

    for(;;)
    {
        S_mid = (S_down + S_up) >> 1;

        if(0 == S_mid)
        {
            return (int)(S_mid);
        }

        S_temp = S_0 / S_mid;

        if(((INT32S)S_mid - (INT32S)S_temp) > PRECISION )
        {
            S_up = S_mid;
        }
        else if(((INT32S)S_mid - (INT32S)S_temp) < (- PRECISION))
        {
            S_down = S_mid;
        }
        else
        {
            return (int)(S_mid);
        }

        S_count ++;

        if(S_count > ITERATION)
        {
            return (int)(S_mid);
        }
    }
}

const INT16S ATAN_CONST[300] =
{
  1,  2,  4,  6,  8, 10, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 72, 74, 76, 78, 80, 82, 84, 86, 87, 89, 91, 93,
 95, 97, 99,101,102,104,106,108,110,112,113,115,117,119,121,123,124,126,128,130,132,134,135,137,139,141,143,144,146,148,150,152,153,155,157,159,160,162,164,166,168,169,171,173,175,176,178,180,181,183,
185,187,188,190,192,193,195,197,199,200,202,204,205,207,209,210,212,214,215,217,219,220,222,224,225,227,229,230,232,233,235,237,238,240,241,243,245,246,248,249,251,252,254,256,257,259,260,262,263,265,
266,268,269,271,273,274,276,277,279,280,282,283,284,286,287,289,290,292,293,295,296,298,299,301,302,303,305,306,308,309,310,312,313,315,316,317,319,320,322,323,324,326,327,328,330,331,332,334,335,336,
338,339,340,342,343,344,346,347,348,350,351,352,353,355,356,357,358,360,361,362,363,365,366,367,368,370,371,372,373,374,376,377,378,379,380,382,383,384,385,386,388,389,390,391,392,393,394,396,397,398,
399,400,401,402,403,405,406,407,408,409,410,411,412,413,414,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,
};
const INT16S SIN_CONST[301] =
{
   1,  52, 105, 157, 209, 262, 314, 366, 419, 471, 523, 576, 628, 680, 732, 785, 837, 889, 941, 993,1045,1097,1149,1201,1253,1305,1357,1409,1461,1513,1564,1616,1668,1719,1771,1822,1874,1925,1977,2028,2079,2130,2181,2233,2284,2334,2385,2436,2487,2538,
2588,2639,2689,2740,2790,2840,2890,2940,2990,3040,3090,3140,3190,3239,3289,3338,3387,3437,3486,3535,3584,3633,3681,3730,3778,3827,3875,3923,3971,4019,4067,4115,4163,4210,4258,4305,4352,4399,4446,4493,4540,4586,4633,4679,4726,4772,4818,4863,4909,4955,
5000,5045,5090,5135,5180,5225,5270,5314,5358,5402,5446,5490,5534,5577,5621,5664,5707,5750,5793,5835,5878,5920,5962,6004,6046,6088,6129,6170,6211,6252,6293,6334,6374,6414,6455,6494,6534,6574,6613,6652,6691,6730,6769,6807,6845,6884,6921,6959,6997,7034,
7071,7108,7145,7181,7218,7254,7290,7325,7361,7396,7431,7466,7501,7536,7570,7604,7638,7672,7705,7738,7771,7804,7837,7869,7902,7934,7965,7997,8028,8059,8090,8121,8151,8181,8211,8241,8271,8300,8329,8358,8387,8415,8443,8471,8499,8526,8554,8581,8607,8634,
8660,8686,8712,8738,8763,8788,8813,8838,8862,8886,8910,8934,8957,8980,9003,9026,9048,9070,9092,9114,9135,9157,9178,9198,9219,9239,9259,9278,9298,9317,9336,9354,9373,9391,9409,9426,9444,9461,9478,9494,9511,9527,9542,9558,9573,9588,9603,9617,9632,9646,
9659,9673,9686,9699,9711,9724,9736,9748,9759,9770,9781,9792,9803,9813,9823,9833,9842,9851,9860,9869,9877,9885,9893,9900,9907,9914,9921,9928,9934,9940,9945,9951,9956,9960,9965,9969,9973,9977,9980,9983,9986,9989,9991,9993,9995,9997,9998,9999,9999,10000,
10000,
};

/*
 * 计算向量(x，y)的角度，输出0~360，放大 10 倍（即0~3600）
 * Outputs:坐标轴，向上x,向右y,角度起始轴为x轴,顺时针方向角度为正
 */
int int_degree(int x, int y)
{
    if(x==0 && y==0)
        return 0;
    if(x==0 && y>0)
        return 900;
    if(x==0 && y<0)
        return 2700;
    if(y==0 && x>0)
        return 0;
    if(y==0 && x<0)
        return 1800;
    int m;
    if(ABS(y) <= ABS(x))
        m = ATAN_CONST[ABS(y)*299/ABS(x)];
    else
        m = 900 - ATAN_CONST[ABS(x)*299/ABS(y)];
    if(x>0 && y>0)
        return m;
    if(x>0 && y<0)
        return 3600-m;
    if(x<0 && y>0)
        return 1800-m;
    if(x<0 && y<0)
        return 1800+m;
    return 0;
}

/*
 * 计算Sin()和Cos()
 * Inputs: 输入角度放大 10 倍
 * Outputs: 输出值放大10000倍
 * Example: sin(30) = 0.5  int_sin(30*10) = 0.5 * 10000
 */
int int_cos(int a)
{
    while(a<0)
    {
        a += 3600;
    }
    while(a>=3600)
    {
        a -= 3600;
    }
    if(a<=900)
        return (int)SIN_CONST[(900-a)/3];
    if(a<=1800)
        return -(int)SIN_CONST[(a-900)/3];
    if(a<=2700)
        return -(int)SIN_CONST[(2700-a)/3];
    return (int)SIN_CONST[(a-2700)/3];
}
int int_sin(int a)
{
    while(a<0)
    {
        a += 3600;
    }
    while(a>=3600)
    {
        a -= 3600;
    }
    if(a<=900)
        return (int)SIN_CONST[a/3];
    if(a<=1800)
        return (int)SIN_CONST[(1800-a)/3];
    if(a<=2700)
        return -(int)SIN_CONST[(a-1800)/3];
    return -(int)SIN_CONST[(3600-a)/3];
}

/*
**	Module Date: 06/27/2008
**	Module Auth: AiN
**  Description: caculation of sin(x) or cos(x) 
 	0:1/100:15 	sin_10000拟合的函数 y=1757*x/1000-196*x*x/10000000
	15:1/100:30 sin_10000拟合的函数 y=187*x/100-58*x*x/1000000-88
	30:1/100:45 sin_10000拟合的函数 y=2078*x/1000-93*x*x/1000000-397
	45:1/100:60 sin_10000拟合的函数 y=232*x/100-12*x*x/100000-940
	60:1/100:90 sin_10000拟合的函数 y=2637*x/1000-146*(x/3)*(x/3)/111115-1909
** Inputs: 	输入角度要扩大 100 倍
** Outputs: 输出值扩大了10000 倍
** example: sin(30) = 0.5  sin_10000(30*100) = 0.5 * 10000
**--------------------------------------------------------------------
**  Revision History:
**  Date:		month/day/year
**  Notes:
** ===================================================================
*/

/*
 *高精度的正弦
 */
signed int sin_value_10000(unsigned long Angle)
{
    long Angle_value = 0;
    if(Angle < 1500)
    {
        Angle_value = 1757 * Angle / 1000 - 196 * Angle * Angle / 10000000;
    }
    else if(Angle < 3000)
    {
        Angle_value = 187 * Angle / 100 - 58 * Angle * Angle / 1000000 - 88;
    }
    else if(Angle < 4500)
    {
        Angle_value = 2078 * Angle / 1000 - 93 * Angle * Angle / 1000000 - 397;
    }
    else if(Angle < 6000)
    {
        Angle_value = 232 * Angle / 100 - 12 * Angle * Angle / 100000 - 940;
    }
    else
    {
        Angle = 9000 - Angle;
        Angle_value = 10000 - 944 * Angle / 100000 - 146 * Angle * Angle / 1000000;
    }
    return Angle_value;
}

signed int sin_10000(signed long Angle)
{
    signed int SinValue = 0;
    while(Angle > 36000)
    {
        Angle = Angle - 36000;
    }
    while(Angle < 0)
    {
        Angle = Angle + 36000;
    }
    if(Angle <= 9000)
    {
        SinValue = sin_value_10000(Angle);
    }
    else if(Angle <= 18000)
    {
        SinValue = 18000 - Angle;
        SinValue = sin_value_10000(SinValue);
    }
    else if(Angle <= 27000)
    {
        SinValue = Angle - 18000;
        SinValue = 0 - sin_value_10000(SinValue);
    }
    else
    {
        SinValue = 36000 - Angle;
        SinValue = 0 - sin_value_10000(SinValue);
    }
    return SinValue;
}

/*
 *高精度余弦
 */
signed int cos_10000(signed long Angle)
{
    signed int CosValue = 0;
    while(Angle > 36000)
    {
        Angle = Angle - 36000;
    }
    while(Angle < 0)
    {
        Angle = Angle + 36000;
    }
    if(Angle <= 9000)
    {
        CosValue = sin_value_10000(9000 - Angle);
    }
    else if(Angle <= 18000)
    {
        CosValue = Angle - 9000;
        CosValue = 0 - sin_value_10000(CosValue);
    }
    else if(Angle <= 27000)
    {
        CosValue = 27000 - Angle;
        CosValue = 0 - sin_value_10000(CosValue);
    }
    else
    {
        CosValue = sin_value_10000(Angle - 27000);
    }
    return CosValue;
}
//arccos()函数
//输入（0,10000）
//输出（0,18000）
signed long arccos_10000(signed int value)
{
  int vax,r;
  int down,up,mid;
  
  if(value < cos_10000(17999))
  {
    return 17999;
  }
  else if(value > cos_10000(1))
  {
    return 1;
  }
  
  vax = ABS(value);
  down = 0;
  mid = 9000;
  up = 17999;
  
  while(up >= down)
  {
    if(vax < cos_10000(mid))
    {
      down = mid + 1;
    }
    else
    {
      up = mid - 1;
    }
    mid = (up + down)>>1;
  }
  
  r = (vax - cos_10000(up)) / (cos_10000(down) - cos_10000(up)) + up;
    
  return r;
}

//arcsin()函数
//输入（-10000,10000）
//输出（-9000,9000）
signed long arcsin_10000(signed int value)
{
  int vax,r;
  int down,up,mid;
  
  if(value < sin_10000(-8999))
  {
    return -8999;
  }
  else if(value > sin_10000(8999))
  {
    return 8999;
  }
  
  vax = ABS(value);
  down = -8999;
  mid = 0;
  up = 8999;
  
  while(up >= down)    //二分法
  {
    if(vax > sin_10000(mid))
    {
      down = mid + 1;
    }
    else
    {
      up = mid - 1;
    }
    mid = (up + down)>>1;
  }
  
  r = (vax - sin_10000(up)) / (sin_10000(down) - sin_10000(up)) + up; //线性插值
    
  if(value < 0)
    r = -r;
  
  return r;
}
/*
 *高精度正切
 */
/*
signed int tan_10000(signed long Angle)
{
    long TanValue;
    if(Angle > 6500) Angle = 6500;
    if(Angle == 0)
    {
        TanValue = 0;
    }
    else
    {
        TanValue = 10000L * sin_10000(Angle) / cos_10000(Angle);
    }
    return TanValue;
}
*/

/*
 * cos_f()函数
 * 输入float 输出float
 */
//float cos_f(float Angle_f)
//{
//    int Angle =(int)(Angle_f*100);
//    float CosValue_f;
//    signed int CosValue = 0;
//    while(Angle > 36000)
//    {
//        Angle = Angle - 36000;
//    }
//    while(Angle < 0)
//    {
//        Angle = Angle + 36000;
//    }
//    if(Angle <= 9000)
//    {
//        CosValue = sin_value_10000(9000 - Angle);
//    }
//    else if(Angle <= 18000)
//    {
//        CosValue = Angle - 9000;
//        CosValue = 0 - sin_value_10000(CosValue);
//    }
//    else if(Angle <= 27000)
//    {
//        CosValue = 27000 - Angle;
//        CosValue = 0 - sin_value_10000(CosValue);
//    }
//    else
//    {
//        CosValue = sin_value_10000(Angle - 27000);
//    }
//    CosValue_f =(float) CosValue/10000;
//    return CosValue_f;
//}

/*
 * sin_f()函数
 * 输入float 输出float
 */
//float sin_f(float Angle_f)
//{
//    int Angle =(int) (Angle_f*100);
//    float SinValue_f;
//    signed int SinValue = 0;
//    while(Angle > 36000)
//    {
//        Angle = Angle - 36000;
//    }
//    while(Angle < 0)
//    {
//        Angle = Angle + 36000;
//    }
//    if(Angle <= 9000)
//    {
//        SinValue = sin_value_10000(Angle);
//    }
//    else if(Angle <= 18000)
//    {
//        SinValue = 18000 - Angle;
//        SinValue = sin_value_10000(SinValue);
//    }
//    else if(Angle <= 27000)
//    {
//        SinValue = Angle - 18000;
//        SinValue = 0 - sin_value_10000(SinValue);
//    }
//    else
//    {
//        SinValue = 36000 - Angle;
//        SinValue = 0 - sin_value_10000(SinValue);
//    }
//    SinValue_f = (float)SinValue/10000;
//    return SinValue_f;
//}

/*
 * tan_f()函数
 * 输入float 输出float
 */
/*
float Tan[] = {
                0,0.0174550649282176,0.0349207694917477,0.0524077792830412,0.0699268119435104,0.0874886635259240,0.105104235265676,0.122784560902905,0.140540834702391,0.158384440324536,
                0.176326980708465,0.194380309137718,0.212556561670022,0.230868191125563,0.249328002843181,0.267949192431123,0.286745385758808,0.305730681458660,0.324919696232906,0.344327613289665,
                0.363970234266202,0.383864035035416,0.404026225835157,0.424474816209605,0.445228685308536,0.466307658154999,0.487732588565861,0.509525449494429,0.531709431661479,0.554309051452769,
                0.577350269189626,0.600860619027560,0.624869351909328,0.649407593197511,0.674508516842427,0.700207538209710,0.726542528005361,0.753554050102794,0.781285626506717,0.809784033195007,
                0.839099631177280,0.869286737816227,0.900404044297840,0.932515086137662,0.965688774807074,1.00000000000000,1.03553031379057,1.07236871002468,1.11061251482919,1.15036840722101,
                1.19175359259421,1.23489715653505,1.27994163219308,1.32704482162041,1.37638192047117,1.42814800674211,1.48256096851274,1.53986496381458,1.60033452904105,1.66427948235052,
                1.73205080756888,1.80404775527142,1.88072646534633,1.96261050550515,2.05030384157930,2.14450692050956,2.24603677390422,2.35585236582375,2.47508685341630,2.60508906469380,
                2.74747741945462,2.90421087767582,3.07768353717526,3.27085261848414,3.48741444384091,3.73205080756888,4.01078093353585,4.33147587428416,4.70463010947846,5.14455401597031,
                5.67128181961772,6.31375151467505,7.11536972238422,8.14434642797461,9.51436445422261,11.4300523027613,14.3006662567119,19.0811366877282,28.6362532829157,57.2899616307599
                };
float tan(float x)
{
    int16 nx,d=1;
    int16 down,up;
    float result=0;
    
    if(x >= 89)
        x=89;
    else if(x <= -89)
        x= -89;
  
    d=x>0?1:-1;
    
    x=ABS(x);
    
    nx = (int16)x;  
    
    if(nx<x)
    {
        down = nx;
        up = nx+1;
        result = (Tan[up]-Tan[down])*(x-nx)+Tan[down];
    }
    else if(nx>x)
    {
        down = nx - 1;
        up = nx;
        result = (Tan[up]-Tan[down])*(nx-x)+Tan[down];
    }
    else
    {
        result= Tan[nx];
    }
    
    return result*d;
}
*/